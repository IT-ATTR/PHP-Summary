# mysql高级编程语法

## 外键

> 使用外键的前提：外键所存在的表必须是Innodb引擎的。

创建外键

```sql
create table tableName(
    foreign key (外键字段) references 主表 (主表关联字段) [删除时执行语句] [更新时执行语句];
)engine=Innodb charset=utf-8;
```

删除外键语句语法

```sql
alter table 表名 drop  foreign key 外键标识;
-- 删除索引
alter table 表名 drop index 索引字段名;
```

添加外键操作

```sql
alter table 表名 add foreign key (外键字段) references 主表 (主表关联字段) [删除时执行语句] [更新时执行语句];
```

外键约束

> -   默认情况下被关联的外键数据是无法删除的
> -   默认情况下被关联的字段值是无法被修改的，非关联字段可以修改
> -   主表关联字段修改后，会影响外键字段的值
> -   主表数据删除后，外键字段会自动修改为NULL值

## 数据库的范式

| 范式名称     | 描述                                    |
| -------- | ------------------------------------- |
| 第一范式：1NF | 原子性：所有的列都不可再分                         |
| 第二范式：2NF | 唯一性：即为数据加入唯一性标识解决重复性的问题               |
| 第三范式：3NF | 依赖性/关联性/冗余性：把多余的数据加入附属表,通过外键和主键进行关联操作 |

> LiveJournal的开发团队发起了反关系型数据库的革命,得到了开发者的响应,并在其中产生了一种违背数据库三范式的思想,DBA工程学把这种技术叫做Lookup,就是人们俗称的逆范式

## 视图

> 应用场景1：保密工作，比如有一个员工工资表，如果你只希望财务看到员工工资这个字段，而其他人不能看到工资字段，那就用一个视图，把工资这个敏感字段过滤掉
>
> 应用场景2：有一个查询语句非常复杂，大概有100行这么多，有时还想把这个巨大无比的select语句和其他表关联起来得到结果，写太多很麻烦，可以用一个视图来代替这100行的select语句，充当一个变量角色

创建视图

```sql
create view 视图名称 as (查询SQL语句);
```

删除视图(不会影响源表)

```sql
drop view 视图名称;
drop view if exists 视图名称;
```

查看数据库中的所有视图

```sql
select * from information_schema.views;
```

-   视图其实是以表子查询的SQL语句的形态存在的
-   操作视图就相当于操作原表(一般不会直接操作视图，保持视图数据的干净)
-   重启MYSQL后，在不同的黑窗口客户端中依然能够使用重启之前创建的视图
-   视图可以在多个客户端进程中通用
-   视图必须在选择数据库之后才能进行操作

## 变量

### 系统变量

查看所有的全局变量操作

```sql
show global variables;
```

> 全局变量指的是MYSQL配置文件中各个配置项的配置信息

查看所有的会话变量操作

```sql
show  session  variables;
```

> 会话变量是在复制一份全局变量的基础上再额外增加了一些包含MYSQL版本等信息的变量集合

修改全局变量

```sql
    set @@global.变量名=变量值;
```

> 全局变量如果在某个客户端中修改了，那么，其他的所有客户端进程也会受到影响。
>
> 重启数据库后，set方式修改的全局变量将会被重新初始化

修改会话变量的语句语法

```sql
set  @@session.变量名=变量值;
```

> 如果在某个客户端中修改了会话变量的值，则只影响当前客户端，不对其他的客户端进程产生任何影响。
>
> 重启MYSQL之后，set方式修改的会话变量的值将会被还原

### 用户变量

> 在MYSQL中定义的用户变量，在不同的客户端进程（不同的黑窗口中）不通用！

定义用户变量

```sql
set @变量名=变量值;
set @变量名=变量值,@变量名=变量值;
```

获取用户变量

```sql
select @变量名,@变量名;
```

通过select语句定义用户变量

```sql
-- 将查询结果中的最后一条数据的name,age,email分别赋值给不同的用户变量
select @var1=name,@var2=age,@var3=email from table where 1;
```

### 局部变量

> 局部变量不能再全局中定义和使用

定义局部变量

```sql
declare 变量名 变量数据类型 [default 默认值];
-- 示例
declare var1 int default 0;
```

## mysql结束符

> 在MYSQL中，默认的语句结束符为分号：“;”，但是mysql支持我们在操作过程中修改语句结束符的符号

修改结束符

```sql
delimiter 新符号
```

## 流程结构

### if分支

```sql
if  条件语句  then
	if结构体
[elseif  条件语句  then
	elseif结构体]
else
	else结构体
end if;

-- 示例
if @var > 100 then
    insert into values('');
else
    insert into values('');
end if;
```

### while循环

```sql
while 条件 do
	循环结构体
end while;
```

## 函数

开始结构标识符：begin

结束结构标识符：end

定义函数

```sql
create  function  函数名(形参1 形参1数据类型, 形参2  形参2数据类型,…, 形参n  形参n数据类型)
returns  预估的函数返回值数据类型
[begin]
函数的结构体
[end]
```

使用函数

```sql
select  函数名(实参列表);
```

> 如果我们在函数中定义了形参列表，则默认这些形参都为局部变量，我们可以通过set的方式来改变局部变量的值。

删除函数操作

```sql
drop  function  函数名;
```

## 存储过程

### 创建存储过程

```sql
create  procedure  存储过程名(数据传递类型  形参1  形参1数据类型, 数据传递类型  形参2  形参2数据类型,…, 数据传递类型  形参n  形参n数据类型)
begin
	存储过程结构体
end
```

### 调用存储过程的语句语法

```sql
call  存储过程名(实参列表);
```

### 参数的传递类型

in  只进不出(只传值不传名)

> 在存储过程中修改值将不影响外部变量

out 只出不进(只传名不传值)

> 在存储过程中无法获得值

inout 能够进也能够出(即传名也传值)

> 最常用的类型

### 删除存储过程

```sql
drop  procedure  存储过程名;
```
