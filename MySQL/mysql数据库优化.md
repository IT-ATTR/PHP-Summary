# mysql数据库优化

## 字段设计规范
|规范|原因|
|-- | --|
|优先选择符合存储需要的最小的数据类型||
|对于非负数数据采用无符号整型进行储存|获取更多的存储空间|
|优先使用最小的长度的数据类型|过大的长度会消耗更多的内存 虽然vachar类型是可变长，储存内容的时候会按照实际情况进行长度改变|
|避免使用text\BLOB数据类型|推荐将text列分离到独立的扩展表|
|禁止使用ENUM枚举数据类型|修改ENUM值时候需要使用ALTER语句，增加数据库操作风险|
|尽可能的把所有列定义为NOT NULL|索引NULL列需要额外的空间来保存，暂用更多的空间 进行比较和计算时候需要对NULL值进行特殊处理|
|尽量避免使用字符串储存日期类型|无法使用日期函数进行计算和比较|
|使用TIMESTAMP 或者 DATEIME类型储存时间|TIMESTAMP 4个字节 范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07 和 INT类型相同 但可读性高|
|财务相关的金额类型数据，必须使用decimal类型|decimal类型为双精度浮点数，在计算时候不会丢失精度 并且占用空间由宽度决定 可以储存比binint更大的整数数据|

## SQL语句优化
|规范|原因|
|-- | --|
|建议使用预编译语句进行数据库操作||
|避免数据类型的隐式转换|隐式转换将会导致索引失效|
|避免使用双%号的查询条件 如 a like '%123%'|将会使得索引失效|
|一个SQL语句只能利用到复合索引中的一列惊喜范围查询||
|使用 left join 或 not exists 来优化 not in 操作|not in不能合理的利用列上的索引|
|程序连接不同的数据库需要使用不同的账号，禁止跨库查询||
|禁止使用 select * 查询|*会消耗更多的cpu和io资源以及网络带宽资源  无法使用覆盖索引|
|禁止使用不含字段列表的insert语句，例如： insert into t values('a','b','c');|减少表结果变更对业务带来的影响|
|尽可能避免使用子查询，可以将子查询优化为join操作|子查询的结果集无法使用索引|
|避免使用join关联太多的表|产生临时表操作，影响查询效率|
|减少同数据库的交互次数||
|在对同一列进行过滤操作 使用in代替or|in操作能更好的利用索引|
|禁止使用 order by rand() 进行随机排序||
|WHERE 从句中禁止对列进行函数转换和计算||
|在明显不会有重复值时使用UNION ALL 而不是UNION|UNION 会将所有数据放到临时表后再进行去重操作|
|拆分复杂的大SQL语句为多个小SQL语句|MySQL中一个SQL语句只能使用一个CPU进行计算 拆分后可以通过并行处理提高效率|
|对大批量的数据操作和数据量较大的表结构修改过程中，必须使用pt-online-schema-change||
|程序使用的账户原则上不允许有drop权限||

## mysql索引建立规范
|规范|原因|
|-- | --|
|限制每张表上的数量索引，最多不超过5个|索引可以增加查询效率，但是同时降低了插入和更新数据的效率|
|每个Innodb表中必须存在一个主键，且不使用UUID,MD5,HASH字符串作为主键|如果表中不存在主键，Innodb会默认将表中最开始的非空字段设置为主键，如果整个表都不存在非空字段，则Innodb会自行生成一个主键字段，但是自行生成的主键字段并非最佳性能|
|建立索引建议|WHERE 从句中的列 ORDER BY、GROUP BY、DISTINCT中的字段 多表JOIN的关联列|
|联合索引的顺序|将区分度最高的列放在联合索引的最左侧 尽量将字段长度小的列放在SQL语句的最左侧|
|避免使用冗余索引和重复索引|MySQL主键默认是已经建立了索引的，所以不需要重复定义索引|
|尽量避免使用Innodb外键索引|Innodb外键会降低写入性能|
